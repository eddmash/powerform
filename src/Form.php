<?php

namespace Eddmash\PowerOrm\Form;

use Eddmash\PowerOrm\BaseObject;
use Eddmash\PowerOrm\ContributorInterface;
use Eddmash\PowerOrm\Exception\FormNotReadyException;
use Eddmash\PowerOrm\Exception\KeyError;
use Eddmash\PowerOrm\Exception\ValidationError;
use Eddmash\PowerOrm\Form\Fields\Field;

/**
 * Class Form.
 *
 * @since 1.0.0
 *
 * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
 */
abstract class Form extends BaseObject implements \IteratorAggregate
{
    use FormFieldTrait;
    const NON_FIELD_ERRORS = '_all_';

    /**
     * Indicates if the form is ready for use, if false, this indicates the form is in customization mode and cannot
     * be used for things like validation.using it when not ready causes inconsistencies in how the form works.
     *
     * Call done() to signal your done customizing the form
     *
     * @var bool
     */
    protected $ready = false;

    /**
     * By default, the form rendering methods include:
     *      - HTML id attributes on the form elements.
     *      - The corresponding <label> tags around the labels. An HTML <label> tag designates which label text is
     *          associated with which form element.
     *          This small enhancement makes forms more usable and more accessible to assistive devices.
     *          It’s always a good idea to use <label> tags.
     *
     * The id attribute values are generated by prepending id_ to the form field names. This behavior is configurable,
     * though, if you want to change the id convention or remove HTML id attributes and <label> tags entirely.
     *
     * Use the auto_id argument to the Form constructor to control the id and label behavior.
     *
     * This argument must be True, False or a string.
     *      - If auto_id is False, then the form output will not include <label> tags nor id attributes
     *      - If auto_id is set to True, then the form output will include <label> tags and will simply use the
     *          field name as its id for each form field.
     *      - If auto_id is set to a string containing the format character '%s', then the form output will include
     *          <label> tags, and will generate id attributes based on the format string. For example,
     *          for a format string 'field_%s', a field named subject will get the id value 'field_subject'.
     *      - If auto_id is set to any other true value – such as a string that doesn’t include %s – then the library
     *          will act as if auto_id is True.
     *
     * By default, auto_id is set to the string 'id_%s'.
     *
     * @var string
     */
    public $auto_id = 'id_%s';
    public $initial = [];
    public $data = [];
    public $is_bound = false;

    /**
     * @var Field[]
     */
    protected $fields = [];
    public $validation_rules = [];
    public $cleaned_data = [];

    /**
     * Takes three arguments.
     *
     * @param array $data the data to bind the form to and validate against, usually you will use data from the $_POST
     *                       but can be an associative array that has any of the form fields names as keys
     * @param array $initial this is the are initial values for the form fields usually the first time the form is
     *                       loaded i.e. unbound form, this should be an associative array where keys are the form fields names
     *
     * You may be thinking, why not just pass a dictionary of the initial values as data when displaying the form?
     * Well, if you do that, you’ll trigger validation, and the HTML output will include any validation errors.
     *
     * This is why initial values are only displayed for unbound forms. For bound forms, the HTML output will use
     * the bound data.
     *
     * Also note that initial values are not used as “fallback” data in validation if a particular field’s value is
     * not given. initial values are only intended for initial form display:
     *
     * <strong>NOTE </strong> this are not default values
     * @param array $kwargs this accepts any other arguments that need to be passed to the form, usually
     *                      this used to accept user defined arguments
     */
    public function __construct($data = [], $initial = [], $kwargs = [])
    {
        if (!empty($data)):
            $this->is_bound = true;
        endif;

        $this->data = $data;

        if (empty($initial)):
            $initial = [];
        endif;

        $this->initial = array_change_key_case($initial, CASE_LOWER);

        // replace the default options with the ones passed in.
        foreach ($kwargs as $key => $value) :
            $this->{$key} = $value;
        endforeach;

        $this->init();
    }

    /**
     * Initializes the object.
     * This method is invoked at the end of the constructor after the object is initialized ;.
     */
    public function init()
    {
    }

    public function fields()
    {
    }

    public function widgets()
    {
    }

    public function custom()
    {
    }

    public function setup()
    {
        $this->fields();

        $this->custom();

        if ($this->_is_multipart()):
            // load the upload library
            Orm::ci_instance()->load->library('upload');
        endif;
        $this->ready = true;
    }

    /**
     * Returns true if the form is bound and its has no errors after validation has been run.
     *
     * @return bool
     *
     * @since 1.1.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    public function isValid()
    {
        $this->_isReady(__METHOD__);

        return $this->is_bound && $this->_form_has_errors();
    }

    /**
     * return a list of errors related to the form and its fields.
     *
     * @return mixed
     *
     * @since 1.1.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    public function errors()
    {
        if (empty($this->_errors)):
            $this->full_clean();
        endif;

        return $this->_errors;
    }

    /**
     * Raise error if form is not ready for use.
     *
     * @param $method
     *
     * @throws FormNotReadyException
     *
     * @since 1.1.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    protected function _isReady($method)
    {
        if (!$this->ready):
            $this->setup();
        endif;
    }

    /**
     * Returns true of form is ready for use or false if its still in customizaiton mode.
     *
     * @return bool
     *
     * @since 1.1.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    public function isReady()
    {
        return $this->ready;
    }

    /**
     * Clean the form and the fields i.e. do the validations for this form and its fields.
     *
     * @since 1.1.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    public function full_clean()
    {
        $this->_errors = [];

        if (!$this->is_bound):
            return;
        endif;
        // a better way of doing validation, easy for users to extend
        $this->_clean_fields();
        $this->_clean_form();
    }


    /**
     * Gets a single field instance in the form fields array and returns it.
     *
     * <h4>Usage</h4>
     *
     * if a form has a fields username, you get the field object:
     *
     * <pre><code>$form->get_field('username);</code></pre>
     *
     * @param $field_name
     *
     * @return mixed
     *
     * @throws KeyError
     *
     * @since 1.0.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    public function get_field($field_name)
    {
        if ((array_key_exists($this->standard_name($field_name), $this->fields))):
            return $this->fields[$this->standard_name($field_name)];
        endif;

        throw new KeyError(sprintf('Field %1$s not found in %2$s', $field_name, $this->get_class_name()));
    }

    /**
     * used to set up field on the form, usually used by a fields contribute method.
     *
     * @param $field
     *
     * @since 1.1.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    public function load_field($field)
    {
        $this->fields[$field->name] = $field;
    }

    /**
     * Sets up so validation rules to be used by the CI_VALIDATION.
     *
     * @since 1.1.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    public function field_validation_rules($rules)
    {
        $this->validation_rules[] = $rules;
    }

    public function clean()
    {
        return $this->cleaned_data;
    }

    public function add_error($name, $error)
    {

        // for consistency convert them to a validation error object
        if (!$error instanceof ValidationError):
            $error = new ValidationError($error);
        endif;

        if (!$name):
            // todo store non field errors as arrays, current can only store one non field per form
            $name = self::NON_FIELD_ERRORS;
        endif;

        // todo deal with a list of validation errors

        $this->_errors[$name] = $error->get_message();
    }

    public function add_field($name, $field)
    {
        $this->_field_setup($name, $field);
    }

    public function non_field_errors()
    {
        if (array_key_exists(self::NON_FIELD_ERRORS, $this->errors())):
            return $this->errors()[self::NON_FIELD_ERRORS];
        endif;

        return [];
    }

    public function hidden_fields()
    {
        $hidden_fields = [];
        foreach ($this->fields as $name => $field) :
            if ($field->isHidden()):
                $hidden_fields[$name] = $field;
            endif;
        endforeach;

        return $hidden_fields;
    }

    public function visible_fields()
    {
        $visible_fields = [];
        foreach ($this->fields as $name => $field) :
            if (!$field->isHidden()):
                $visible_fields[$name] = $field;
            endif;
        endforeach;

        return $visible_fields;
    }

    /**
     * @return string
     *
     * @since 1.1.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    public function as_p()
    {
        return $this->_html_output(
            [
                'row' => '<p>%1$s <br> %2$s <br> %3$s</p>',
            ]
        );
    }

    public function validator()
    {
        if (empty($this->validator)):
            Orm::ci_instance()->load->library('form_validation');
            $this->validator = Orm::ci_instance()->form_validation;
        endif;

        return $this->validator;
    }

    public function _clean_fields()
    {
        // who survived the CI_validator?
        $this->cleaned_data = array_diff_key($this->data, $this->_errors);

        foreach ($this->fields as $name => $field) :

            // if field has failed validation, no need to go on
            if (array_key_exists($name, $this->_errors)):
                continue;
            endif;

            if ($field->disabled):
                $value = array_key_exists($name, $this->initial) ? $this->initial[$name] : $field->initial;
            else:
                if (array_key_exists($name, $this->cleaned_data)):

                    $value = $field->widget->value_from_data_collection($this->cleaned_data, $name);
                else:
                    $value = $field->data();
                endif;
            endif;

            try {
                // run default field validations
                $field->clean($value);

                // just in case,  confirm the field has not field validation already
                if (!array_key_exists($name, $this->_errors)):
                    $this->cleaned_data[$name] = $value;
                endif;

                // run custom validation by user
                $field_clean_method = sprintf('clean_%s', $name);
                if ($this->hasMethod($field_clean_method)):
                    $value = call_user_func([$this, $field_clean_method]);
                    $this->cleaned_data[$name] = $value;
                endif;
            } catch (ValidationError $e) {
                $this->add_error($name, $e);

                if (array_key_exists($name, $this->cleaned_data)):
                    unset($this->cleaned_data[$name]);
                endif;
            }

        endforeach;
    }

    public function _clean_form()
    {
        try {
            $clean_data = $this->clean();
        } catch (ValidationError $e) {
            $clean_data = null;
            $this->add_error(null, $e);
        }

        if ($clean_data):
            $this->cleaned_data = $clean_data;
        endif;
    }

    public function _form_has_errors()
    {
        return empty($this->errors());
    }

    protected function _is_multipart()
    {
        if (empty($this->fields)):
            return false;
        endif;

        foreach ($this->fields as $field) :
            if ($field->widget->needs_multipart_form):
                return true;
            endif;
        endforeach;
    }

    /**
     * @return string
     *
     * @since 1.0.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    protected function _html_output($opts = [])
    {
        //todo display errros
        /** @var $field Field */
        $top_errors = $this->non_field_errors();
        $row = '';
        extract($opts);

        $output = [];
        $hidden_output = [];

        foreach ($this->fields as $name => $field) :
            if ($field->isHidden()):
                $hidden_output[] = (string)$field;
            else:
                $output[] = sprintf($row, $field->labelTag(), $field, $field->helpText);
            endif;
        endforeach;

        // add errors to the top

        // add hidden inputs to end
        $output = array_merge($output, $hidden_output);

        return implode(' ', $output);
    }

    protected function _field_setup($name, $value)
    {
        if ($value instanceof ContributorInterface):
            $value->contributeToClass($name, $this);
        else:
            $this->{$name} = $value;
        endif;
    }

    public function getIterator()
    {
        $this->setup();

        return new \ArrayIterator($this->fields);
    }

    /**
     * @ignore
     *
     * @param $field_name
     *
     * @return mixed
     *
     * @throws KeyError
     *
     * @since 1.0.0
     *
     * @author Eddilbert Macharia (http://eddmash.com) <edd.cowan@gmail.com>
     */
    public function __get($field_name)
    {
        $this->setup();
        if (array_key_exists($field_name, $this->fields)):
            return $this->get_field($field_name);
        endif;
    }

    public function __set($name, $value)
    {
        $this->_field_setup($name, $value);
    }

    public function __toString()
    {
        $this->setup();

        return $this->as_p();
    }
}
